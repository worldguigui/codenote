在学习antlr4的使用时，我被建议去了解一下lambda演算，以下是我对教材内容的总结。<br/>

## 一.什么是lambda演算？

## 二.lambda的语法
```
<expression> ::= <variable> ; lowercase identifiers
                | <constant> ; predefined objects
                | ( <expression> <expression> ) ; combinations
                | ( λ <variable> . <expression> ) ; abstractions.
```
由labmda演算具体语法的 BNF 规范中我们可以看到lambda有四种类型：变量、预定义常量、函数应用(组合)、函数定义(λ抽象)。<br/>
在书中为了方便讲解，预定义了几个常量：数字、add(用于加法)、mul(用于乘法)、succ(后继函数)、sqr(用于平方)<br/><br/>
我们接下来解释相关概念。<br/>

### 1.抽象、变量、预定义常量、后继函数、函数应用
  表达式 **①λn . (add n 1)** 表示整数上的后继函数，因此 **②((λn . (add n 1)) 5) = 6**。<br/>
 * 例子中的表达式①就是λ抽象，也就是函数定义；<br/>
 * n是变量，如x，y，z一样都是我们熟悉的变量；<br/>
 * "add" 和 1 是预定义常量，即如果我们不提前声明，形如“add”和“1”的两串字符是无法表示加与整数的。<br/>
 * 表达式①是整数上的后继函数，简单理解就是，求下一个数字。<br/>
 * 例子中的表达式②就是函数应用，也就是组合。根据定义所说，组合的格式为(E1 E2)，E1和E2都是表达式，我们也可以叫做元变量(metavariable)。这里的E1是一个抽象，E2是一个参数。<br/>

lambda演算式往往会有极其多的括号，以下记法约定允许我们适当地省略括号。<br/>
### 2.五条约定
一个有着较多括号的lambda表达式：**(λn . (λf . (λx . f (n f x)))) (λn . (λf . (λx . f (n f x))))**
#### 1)大写字母和以大写字母开头的标识符将用作元变量，可以用来表示λ表达式和参数。
#### 2)函数应用是左结合的。
E1 E2 E3 表示 ((E1 E2) E3) 而不是 (E1 (E2 E3))。
#### 3)函数定义中 "λ<变量>" 的作用域尽可能向右延伸。
λx . E1 E2 E3 表示 (λx . (E1 E2 E3)) 而不是 ((λx . E1 E2) E3)。<br/>
需要注意的是，应用的优先级高于定义。对于表达式 λx. E1 E2，正确顺序为 λx. (E1 E2)，也就是说 (E1 E2) 是应用，它们优先结合。<br/>
#### 4)抽象允许一个变量列表，该列表缩写了一系列 λ 抽象。
λx y z . E 表示 (λx . (λy . (λz . E)))
#### 5)为表达式命名。
定义为 λ 表达式抽象的函数是匿名的，因此 λ 表达式本身表示该函数。作为一种记法约定，可以使用语法 **define <名称> = <表达式>** 来命名 λ 表达式。<br/>
给定**define Twice = λf . λx . f (f x)**，则有 **(Twice (λn . (add n 1)) 5) = 7**。<br/>


## 三.柯里化函数(Curried Functions)
如上所述的 λ 演算似乎只允许单变量函数。抽象机制一次只允许一个参数。<br/>
然而，许多有用的函数，例如二元算术运算，需要多个参数；例如，**sum(a,b) = a+b** 符合语法规范 **sum : NxN → N** (输入一个有序对，输出一个数。这个类型描述了一个加法函数的行为)，其中 N 表示自然数。<br/>
针对这个问题，lambda演算有两种解决方案：1)用有序对Pair来接收多个参数。2)使用函数的柯里化版本。<br/>
### 1.有序对Pair
在lambda演算中的Pair是一种可以存储两个值的数据结构。既然lambda表达式只能接收一个参数，那么以一个Pair作为参数即可。<br/>
Pair有Head和Tail两种操作，Head表示取第一个值，Tail表示取第二个值。<br/>
可以通过使用预定义的 "cons" 操作（如 Lisp 中）来提供对，或者使用纯 λ 演算中的原始 λ 表达式来定义。<br/>
如<br/>
* <a,b> = cons a b；add <a,b><br/>
* λa . λb . add a b<br/>
### 2.柯里化函数
柯里化函数--将一个接收多个参数的函数，转换成一系列嵌套的、每个只接收一个参数的函数。<br/>
非柯里化版本：sum : NxN → N<br/>
柯里化版本：add : N → N → N (→ 是右结合的)<br/>
### 3.柯里化函数的优势
* a) 部分应用(partial application)<br/>
这是柯里化最强大的特性。你可以只提供一部分参数，得到一个新的、有用的函数。<br/>
如：<br/>
(add 1) 就是后继函数 succ。<br/>
因为 (add 1) 返回一个函数 λb . 1 + b，这个函数的作用正是“加一”。<br/>
* b) 与高阶函数完美配合<br/>
柯里化使得创建和组合函数变得极其方便。<br/>
如：<br/>
**define Twice = λf . λx . f (f x)**(将一个函数应用两次，上文提到过)<br/>
**(Twice sqr)** 得到一个“求四次方”的函数。<br/>
**(Twice (add 1))** 得到一个“加二”的函数。<br/>
你不需要预先定义 FourthPower 或 AddTwo，通过部分应用柯里化函数，可以即时生成它们。<br/>
### 4.柯里化与反柯里化(Curry and Uncurry)
函数的柯里化和反柯里化操作可以在 λ 演算中表示为：<br/>
```
deﬁne Curry = λf . λx . λy . f <x,y>
deﬁne Uncurry = λf . λp . f (head p) (tail p)
```
通过 Curry 和 Uncurry 操作，它们可以在柯里化形式和非柯里化形式（使用有序对的形式）之间进行转换，证明这两种表达方式是等价的。<br/>
因此，加法操作的两种版本有如下关系：<br/>
```
Curry sum = add and Uncurry add = sum
```
具体的证明过程教材中没有提到，只给出了结论。嗯，至少学到这里没有提及。<br/>
