在学习antlr4的使用时，我被建议去了解一下lambda演算，以下是我对教材内容的总结。<br/>

## 一.什么是lambda演算？

## 二.lambda的语法
```
<expression> ::= <variable> ; lowercase identifiers
                | <constant> ; predefined objects
                | ( <expression> <expression> ) ; combinations
                | ( λ <variable> . <expression> ) ; abstractions.
```
由labmda演算具体语法的 BNF 规范中我们可以看到lambda有四种类型：变量、预定义常量、函数应用(组合)、函数定义(λ抽象)。<br/>
在书中为了方便讲解，预定义了几个常量：数字、add(用于加法)、mul(用于乘法)、succ(后继函数)、sqr(用于平方)<br/><br/>
我们接下来解释相关概念。<br/>

### 1.抽象、变量、预定义常量、后继函数、函数应用
  表达式 **①λn . (add n 1)** 表示整数上的后继函数，因此 **②((λn . (add n 1)) 5) = 6**。<br/>
 * 例子中的表达式①就是λ抽象，也就是函数定义；<br/>
 * n是变量，如x，y，z一样都是我们熟悉的变量；<br/>
 * "add" 和 1 是预定义常量，即如果我们不提前声明，形如“add”和“1”的两串字符是无法表示加与整数的。<br/>
 * 表达式①是整数上的后继函数，简单理解就是，求下一个数字。<br/>
 * 例子中的表达式②就是函数应用，也就是组合。根据定义所说，组合的格式为(E1 E2)，E1和E2都是表达式，我们也可以叫做元变量（metavariable）。这里的E1是一个抽象，E2是一个参数。<br/>

lambda演算式往往会有极其多的括号，以下记法约定允许我们适当地省略括号。<br/>
### 2.五条约定
一个有着较多括号的lambda表达式：**(λn . (λf . (λx . f (n f x)))) (λn . (λf . (λx . f (n f x))))**
#### 1) 大写字母和以大写字母开头的标识符将用作元变量，可以用来表示λ表达式和参数。
#### 2) 函数应用是左结合的。
E1 E2 E3 表示 ((E1 E2) E3) 而不是 (E1 (E2 E3))。
#### 3) 函数定义中 "λ<变量>" 的作用域尽可能向右延伸。
λx . E1 E2 E3 表示 (λx . (E1 E2 E3)) 而不是 ((λx . E1 E2) E3)。<br/>
需要注意的是，应用的优先级高于定义。对于表达式 λx. E1 E2，正确顺序为 λx. (E1 E2)，也就是说 (E1 E2) 是应用，它们优先结合。<br/>
#### 4) 抽象允许一个变量列表，该列表缩写了一系列 λ 抽象。
λx y z . E 表示 (λx . (λy . (λz . E)))
#### 5) 为表达式命名。
定义为 λ 表达式抽象的函数是匿名的，因此 λ 表达式本身表示该函数。作为一种记法约定，可以使用语法 **define <名称> = <表达式>** 来命名 λ 表达式。<br/>
给定**define Twice = λf . λx . f (f x)**，则有 **(Twice (λn . (add n 1)) 5) = 7**。<br/>


## 三.柯里化函数（Curried Functions）
如上所述的 λ 演算似乎只允许单变量函数。抽象机制一次只允许一个参数。<br/>
然而，许多有用的函数，例如二元算术运算，需要多个参数；例如，**sum(a,b) = a+b** 符合语法规范 **sum : NxN → N** （输入一个有序对，输出一个数。这个类型描述了一个加法函数的行为），其中 N 表示自然数。<br/>
针对这个问题，lambda演算有两种解决方案：1)用有序对Pair来接收多个参数。2)使用函数的柯里化版本。<br/>
### 1.有序对Pair
在lambda演算中的Pair是一种可以存储两个值的数据结构。既然lambda表达式只能接收一个参数，那么以一个Pair作为参数即可。<br/>
Pair有Head和Tail两种操作，Head表示取第一个值，Tail表示取第二个值。<br/>
可以通过使用预定义的 "cons" 操作（如 Lisp 中）来提供对，或者使用纯 λ 演算中的原始 λ 表达式来定义。<br/>
如<br/>
* <a,b> = cons a b；add <a,b><br/>
* λa . λb . add a b<br/>
### 2.柯里化函数
柯里化函数--将一个接收多个参数的函数，转换成一系列嵌套的、每个只接收一个参数的函数。<br/>
非柯里化版本：sum : NxN → N<br/>
柯里化版本：add : N → N → N （→ 是右结合的）<br/>
### 3.柯里化函数的优势
#### 1) 部分应用(partial application)<br/>
这是柯里化最强大的特性。你可以只提供一部分参数，得到一个新的、有用的函数。<br/>
如：<br/>
(add 1) 就是后继函数 succ。<br/>
因为 (add 1) 返回一个函数 λb . 1 + b，这个函数的作用正是“加一”。<br/>
#### 2) 与高阶函数完美配合<br/>
柯里化使得创建和组合函数变得极其方便。<br/>
如：<br/>
**define Twice = λf . λx . f (f x)**（将一个函数应用两次，上文提到过）<br/>
**(Twice sqr)** 得到一个“求四次方”的函数。<br/>
**(Twice (add 1))** 得到一个“加二”的函数。<br/>
你不需要预先定义 FourthPower 或 AddTwo，通过部分应用柯里化函数，可以即时生成它们。<br/>
### 4.柯里化与反柯里化（Curry and Uncurry）
函数的柯里化和反柯里化操作可以在 λ 演算中表示为：<br/>
```
deﬁne Curry = λf . λx . λy . f <x,y>
deﬁne Uncurry = λf . λp . f (head p) (tail p)
```
通过 Curry 和 Uncurry 操作，它们可以在柯里化形式和非柯里化形式（使用有序对的形式）之间进行转换，证明这两种表达方式是等价的。<br/>
因此，加法操作的两种版本有如下关系：<br/>
```
Curry sum = add and Uncurry add = sum
```
具体的证明过程教材中没有提到，只给出了结论。嗯，至少学到这里没有提及。<br/>

## 四.lambda表达式的语义（Semantics of Lambda Expressions）
一个λ表达式的含义，就是当它所有的函数应用都执行完毕后，得到的最终结果。这个过程，叫做归约（reduction）。<br/>
下部分再深入λ表达式的归约，这部分要先了解前置知识：替换。<br/>
### 1.自由变量和绑定变量
定义：变量 v 在 λ 表达式中的一次出现，如果它在 "λv" 的作用域内，则称为绑定的；否则称为自由的。<br/>
一个变量可以在同一个 λ 表达式中既绑定又自由地出现；例如，在 **λx . y λy . y x** 中，y 的第一次出现是自由的，另外两次是绑定的。<br/>
### 2.替换与安全的替换
**E[v→E1]** 指的是通过用 λ 表达式 E1 替换 E 中变量 v 的每个自由出现而得到的 λ 表达式。<br/>
如果 E1 中的自由变量没有因为替换 **E[v→E1]** 而变成绑定的，则这种替换被称为有效的或安全的。无效的替换涉及变量捕获或名称冲突。<br/>
例如，朴素的替换 **(λx . (mul y x))[y→x]** 得到 **(λx . (mul x x))** 是不安全的，因为结果表示一个平方操作，而原始的 λ 表达式并非如此。<br/>
### 3.识别E中自由变量的操作FV
定义：表达式 E 中自由变量（自由出现的变量）的集合，记作 FV(E)。<br/>
替换的定义需要小心以避免变量捕获。我们首先需要通过定义一个列出表达式中自由出现的变量的操作来识别 E 中的自由变量。例如，**FV(λx . y λy . y x z) = {y,z}**(遵循③④)。<br/>
并遵循以下规则：<br/>
#### 1) FV(c) = ∅ for any constant
#### 2) FV(x) = {x} for any variable 
#### 3) FV(E1 E2) = FV(E 1) ∪ FV(E2)
#### 4) FV(λx . E) = FV(E) - {x} 
没有自由变量（FV(E) = ∅）的 λ 表达式 E 被称为封闭的。
### 4.替换的几种情况
#### 1) v[v→E1] = E1 for any variable v
#### 2) x[v→E1] = x for any variable x≠v
#### 3) c[v→E1] = c for any constant c
#### 4) (Erator Erand)[v→E1] = ((Erator[v→E1]) (Erand[v→E1]))
#### 5) (λv . E)[v→E1] = (λv . E)
#### 6) (λx . E)[v→E1] = λx . (E[v→E1]) when x≠v and x∉FV(E1)
#### 7) (λx . E)[v→E1] = λz . (E[x→z][v→E1]) when x≠v and x∈FV(E1),where z≠v and z∉FV(E E1)
```
Example : (λy . (λf . f x) y)[x→f y]
(λy . (λf . f x) y)[x→f y]
= λz . ((λf . f x) z)[x→f y]         by 7) since y∈FV(f y)
= λz . ((λf . f x)[x→f y] z[x→f y])  by 4)
= λz . ((λf . f x)[x→f y] z)         by 2)
= λz . (λg . (g x)[x→f y]) z         by 7) since f∈FV(f y)
= λz . (λg . g (f y)) z              by 4), 2), and 1) 
```
情况1很好理解，把变量v直接替换成E1。<br/>
情况2、3，不作替换。<br/>
情况4，可以理解为乘法分配律。对操作符和操作数分别进行替换。<br/>
情况5，变量v是绑定的，所以不受替换影响，不会改变。<br/>
情况6，变量x是绑定的，但是与目标变量v不同，所以可以安全地替换。<br/>
情况7，变量x是绑定地，且与目标变量v不同，但x在E1中是自由的，直接替换就会让 x 被外层的 λx 错误地捕获，改变其语义（x 在 E1 中从自由变成绑定）。所以需要将抽象体的绑定变量 x 重命名为一个全新的变量，例如 z。然后再进行替换。<br/>
比如说，λ表达式：**(λx. y x) [y → (f x)]**。直接替换：**(λx. f x x)**。先重命名：**(λz. y z) [y → (f x)]**。再替换：**(λz. f x z)**。<br/>

## 五.λ归约（Lambda Reduction）
这里有个简单的概念--**可归约式**，就是可以被归约的表达式，β-可归约式，就是可以被β归约的表达式。<br/>
### 1.α归约
作用：更改表达式中绑定变量的名称。<br/>
定义：如果 v 和 w 是变量且 E 是 λ 表达式，**λv . E ⇒ α λw . E[v→w]**（把v重命名为w）。<br/>

### 2.β归约
作用：将一个函数应用到一个参数。<br/>
定义：如果 v 是变量且 E 和 E1 是 λ 表达式，**(λv . E) E 1 ⇒ β E[v→E 1]**。我自己理解的是，相当于有一个函数f(x)=g(x)+1，β归约就是要把具体的g(x)带入，求得f(x)。在lambda表达式中叫做替换。<br/>
比如说对于表达式：**((λx. λy. add x y) 2) 3**。<br/>
①识别可归约式：**((λx. λy. add x y) 2)**。<br/>
②应用规则：**(λx. E) Arg ⇒β E[x→Arg]**。<br/>
③这里 **E = (λy. add x y)， Arg = 2**。<br/>
④结果：**(λy. add 2 y) 3**。<br/>
接下来就是以同样的步骤，继续识别可归约式、计算，直到不可β归约为止。<br/>

### 3.η归约
作用：去掉多余的绑定变量。<br/>
因为在lambda表达式中，两个函数如果对所有的输入都产生相同的输出，那么它们就是同一个函数。基于此，我们可以进行η归约。<br/>
定义：如果 v 是变量，E 是 λ 表达式（表示一个函数），并且 v 在 E 中没有自由出现，**λv . (E v) ⇒η E**。<br/>
比如说：<br/>
归约前：**λx. (sqr x)** （一个接收x并将其传给sqr的函数）。<br/>
归约后：**sqr** 。（sqr函数本身）<br/>

### 4.δ归约
作用：进行最终的计算。<br/>
定义：如果 λ 演算有预定义常量（即，如果它不是纯的），与那些预定义值和函数相关的规则被称为 δ 规则。这就相当于把具体的x=1值带入到f(x)=x+1函数中，然后得到了f(x)=2。<br/>
例如，**(add 3 5) ⇒ δ 8** 和 **(not true) ⇒ δ false**。<br/>

## 六.归约策略
这一节主要解决一个问题：当表达式中有多个可归约式时，我们应该先归约哪一个？<img width="207" height="108" alt="image" src="https://github.com/user-attachments/assets/0aa42c6e-a510-4b3e-ba82-91b8ca6bfca8" /><br/>
在回答这个问题之前，我们要先明确：操作 λ 表达式的主要目标是将其归约为一个"最简单的形式"，并将其视为 λ 表达式的值。<br/>
定义：如果 λ 表达式不包含 β-可归约式（在应用 λ 演算中也不包含 δ-规则），则它处于规范形式，因此无法使用 β-规则或 δ-规则进一步归约。<br/>
规范形式和归约策略的概念可以通过提出四个问题来研究：<br/>
### 1.每个 λ 表达式都能归约为规范形式吗？
答案是否定的。<br/>
这个 β-可归约式归约为自身，意味着唯一的归约路径永远继续：<br/>
```
(λx . x x) (λx . x x) ⇒β
(λx . x x) (λx . x x) ⇒β (λx . x x) (λx . x x) ⇒β …
```
### 2.归约一个特定的 λ 表达式是否有多种方法？
答案是肯定的。<br/>
我们既可以用不同的归约顺序得到相同的结果：<br/>
```
Example : (λx . λy . (add y ((λz . (mul x z)) 3))) 7 5
Path 1: (λx . λy . (add y ((λz . (mul x z)) 3))) 7 5
⇒β (λy . (add y ((λz . (mul 7 z)) 3))) 5
⇒β (add 5 ((λz . (mul 7 z)) 3))
⇒β (add 5 (mul 7 3 )) ⇒δ (add 5 21 ) ⇒δ 26
Path 2: (λx . λy . (add y ((λz . (mul x z)) 3))) 7 5
⇒β (λx . λy . (add y (mul x 3))) 7 5
⇒β (λy . (add y (mul 7 3))) 5
⇒δ (λy . (add y 21)) 5 ⇒β (add 5 21 ) ⇒δ 26
```
也可以用不同的归约顺序得到完全不同的结果：
```
Example : (λy . 5) ((λx . x x) (λx . x x))
Path 1: (λy . 5) ((λx . x x) ( λx . x x)) ⇒β 5
Path 2: (λy . 5) ((λx . x x) (λx . x x) )
⇒β (λy . 5) ((λx . x x) (λx . x x) )
⇒β (λy . 5) ((λx . x x) (λx . x x) ) …
```

这两种归约策略分别叫：规范序规约和应用序归约。<br/>
**规范序归约**总是首先归约最左边最外层的 β-可归约式（或 δ-可归约式）。<br/>
**应用序归约**总是首先归约最左边最内层的 β-可归约式（或 δ-可归约式）。<br/>
### 3.如果有多种归约策略，每种策略是否都会得到相同的规范形式表达式？
### 4.是否存在一种归约策略能保证产生规范形式表达式？


