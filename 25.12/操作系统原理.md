# 操作系统原理

## 一.操作系统概述
操作系统，Operating System，OS，一句话概括，它会为你完成所有“硬件相关、应用无关”的工作，给你带来方便、效率、安全。<br/>

### 1.地位
对于整个计算机系统来讲，它通常由两部分组成：软件和硬件。<br/>
软件包含两部分：应用软件和系统软件。<br/>
系统软件包含两部分：操作系统和编译软件、汇编软件、数据库管理系统等支撑软件（帮助应用软件被编译或高效运行）。<br/>

他们之间有如下的抽象关系：<br/>

&emsp;应用软件&emsp;|<br/>
——————<br/>
&emsp;&emsp;支撑软件&emsp;&emsp;|<br/>
————————<br/>
&emsp;&emsp;&emsp;操作系统&emsp;&emsp;&emsp;|<br/>
——————————<br/>
&emsp;&emsp;&emsp;&emsp;计算机硬件&emsp;&emsp;&emsp;&emsp;|<br/>
—————————————<br/>

地位：操作系统紧贴计算机硬件之上，所有其他软件之下，是各种软件的基础运行平台。<br/>

### 2.作用
OS的核心目标是高效管理硬件资源，为用户和应用程序提供稳定、安全、易用的运行环境。<br/>

抽象/易用性：将复杂的硬件操作封装成简单、一致的抽象（如“文件”、“进程”），提供统一的设备访问接口，隐藏各设备细节，让程序员和用户无需关心底层细节。<br/>
高性能：让硬件资源（特别是CPU和内存）得到最充分、最合理的利用，减少空闲和浪费。<br/>
公平性：在多个竞争资源的程序（进程）之间进行合理调度（如CPU时间片轮转），保证每个任务都有机会运行，防止某个程序独占资源。<br/>
稳定性：防止一个程序的错误（如非法内存访问）导致整个系统崩溃。<br/>
安全性：对公共系统资源访问提供保护、竞争等功能，对出现的各种错误进行响应、报告。<br/>

### 3.定义
操作系统是一组系统软件的集合，它作为计算机硬件和应用软件/用户之间的中介，管理和控制计算机系统的所有硬件与软件资源，并为用户和应用程序提供一个高效、稳定、安全的运行环境。<br/>

资源，指的是 计算机系统中任何有限的、并且能够被请求、分配、使用和释放的实体。它们有限、可竞争、可管理。<br/>
硬件资源是物理意义上存在的计算机组件，包括硬盘、内存等。<br/>
软件资源是由操作系统内核创建和维护的、用于支持程序运行的逻辑实体，如消息队列、信号量等。它们物理意义上不存在，但也占据一定的硬件资源。<br/>

### 4.发展史
历史不是简单的编年表，而是一条由核心需求（更高效地利用硬件、更方便地与人交互、更稳定地提供服务）驱动，并受限于或得益于当时硬件水平的逻辑链条。<br/>

**1946-1955：电子管时代，无操作系统**<br/>
手工操作阶段，由程序员提前在纸带上打好孔，然后装入纸带输入机。<br/>
此时的计算机内存极小、不稳定。<br/>
内存小，意味着计算机无法容纳一个常驻的“系统”，我们只能让人工来处理输入输出；<br/>
不稳定，意味着机器频繁故障，需要人工干预。<br/>

计算前，手工装入纸带或卡片；人工控制程序执行；计算完成后，手工卸取纸带或卡片。<br/>
用户独占全机资源，在手工操作时，CPU一直在等待用户。再加上此时的计算机高速的cpu运算和低速的人工，导致CPU利用率极低。<br/>

**1955-1965：晶体管时代，单道批处理系统**<br/>
晶体管更小、更快、更可靠。出现了更快的磁芯内存和磁带作为外部存储。<br/>
此时我们计算机的内存更大，足以容纳一个简单的监控程序，操作员事先将若干作业分组，称为一批作业，输入到输入设备上。这个程序可以按顺序读入每个作业并执行。<br/>
这就是单道批处理系统。<br/>

特征：批量性、自动性、顺序性、单道性。<br/>

因为加入了监督程序，作业转换时间减少，系统运行效率提高。<br/>
但是计算机的内存仍有限，在同一时刻，只允许存在一个用户作业并运行。<br/>
虽然此时监控程序允许作业的自动切换，使得资源转换时间减少，但高速CPU还是会在低速I/O操作中等待。<br/>

**1965-1980：集成电路时代，多道批处理系统、分时操作系统、实时操作系统**<br/>
集成电路使计算机性能飙升。<br/>

- 多道批处理系统：<br/>

在内存中同时存放多道已开始运行且尚未结束的程序。它们交替运行，共享系统中的各种资源，从而使处理机得到充分利用。<br/>
当某道程序因为某种原因（例如执行I/O操作时）不能继续运行而放弃CPU时，OS便调度另一程序投入运行。这样可以使CPU和外部设备尽量忙碌。<br/>

特点：多道运行、宏观上并发、微观上串行。<br/>

主存中会有两道及以上的程序在执行中；<br/>
从宏观上看，它们在同时执行；<br/>
从微观上看，它们在交替执行，因为在任一时刻，在一台处理机上只能执行一道程序的一条指令。 <br/>

缺点：交互性差。<br/>

只有在程序结束或中断时，才能与用户交互。<br/>

- 分时操作系统：<br/>

将处理机的运行时间分成很短的时间片，按时间片轮流将处理机分配给各联机终端使用。<br/>
交互式地向系统提出命令请求。<br/>
多个用户分享使用同一台计算机，系统接受每个用户的命令。<br/>
采用时间片轮转方式处理服务请求。如果某用户在分配给它的时间片用完时仍未完成，则暂时中断，等待下一轮运行，并把处理机的控制权让给另一个终端用户使用。<br/>
通过交互方式在终端上向用户显示结果。<br/>
用户根据上步结果发出下道命令 。<br/>

特点：<br/>
多路性：多个用户同时使用一台计算机工作。共享系统资源，提高了资源利用率。<br/>
及时性：用户能在很短时间内得到系统响应。<br/>
独立性：各用户独立操作，互不干扰，好像独占主机。<br/>
交互性：系统能及时对用户的操作进行响应，加快调试过程，缩短了周转时间。<br/>

- 实时操作系统：<br/>

指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。<br/>
计算机开始应用到军事、工业控制领域，对于准时可靠有着极高的要求。<br/>

分类：（根据“错过截止期限”的容忍程度）<br/>
硬实时操作系统：绝对不允许错过截止期限。错过期限意味着系统的完全失败，可能导致灾难性后果。<br/>
软实时操作系统：尽可能不要错过截止期限。偶尔错过是可以接受的，只会导致服务质量下降，不会导致系统崩溃。<br/>

特点：<br/>
响应时间短：任务有明确和固定的时间约束，在一定范围之内必须作出响应。否则任务就会失败，有可能造成灾难性后果。<br/>
系统可靠性高。<br/>

**1980-至今：超大规模集成电路时代，微机操作系统、网络操作系统、分布式操作系统、嵌入式操作系统**<br/>
硬件资源产生飞跃，微处理器出现，个人计算机革命爆发。人们更多考虑如何用好、管好、隔离好。<br/>

衍生的分类：<br/>
微机操作系统：小型化的计算机的操作系统，为单个用户提供丰富、友好的交互体验。<br/>
网络操作系统：拥有网络功能的操作系统，支持进行基于网络协议的可靠的数据传输。<br/>
分布式操作系统：什么是分布式系统？将大量的计算机组织在一起，通过网络进行连接。该操作系统管理 “通过网络连接的多台独立计算机” ，将它们虚拟成一台更强大的单一计算机给用户使用。用户感觉自己在用一台机器，但后台工作可能分布在多台机器上。<br/>
嵌入式操作系统：什么是嵌入式系统？它们是一个大设备、装置或系统中的一部分，完成特定功能的软硬件系统。该操作系统是 “嵌入式环境下的专用计算机系统” 。这个系统通常只为完成特定的控制或处理任务而存在。<br/>

## 二.计算机和操作系统结构
### 1.操作系统和用户的接口
我们（用户和程序员）怎么使用操作系统？
通过命令接口（用户）或程序接口（程序员）。

**命令接口**<br/>
联机接口(交互式)：使用系统提供的操作命令，交互地控制程序执行和管理计算机系统。如系统管理、环境设置、权限管理、文件管理等。<br/>
脱机接口：以作业说明书的方式提交给系统(批方式）。执行过程中，用户无法干涉。<br/>

**程序接口(系统调用)** <br/>
这是操作系统为编程人员提供的唯一接口，编程人员利用系统调用，可以在程序中调用操作系统所提供的子功能。程序级接口只能在高级语言或汇编语言中作为函数和过程被调用。<br/>

**命令解释系统**<br/>
也叫做shell(外壳)，是OS的重要组件之一，它读入用户的输入或者文件中的命令并运行。通常转换为一个或者多个系统调用。<br/>

有的是在内核中。<br/>
有的则将它作为一个特殊程序，当作业开始或者分时系统中用户登陆时，它运行。如：Unix。<br/>

工作流程<br/>
接收命令：从终端（命令行界面）或脚本文件中读取用户输入的命令。<br/>
解释命令：分析命令字符串，识别命令名、参数、选项和重定向等特殊符号。<br/>
执行命令：<br/>
如果是内部命令（built-in command）：由Shell自身直接执行（如 cd, exit）。<br/>
如果是外部命令：在文件系统中查找对应的可执行程序文件（如 ls, grep），然后通过系统调用（如 fork() + exec()）创建新进程来执行它。<br/>

### 2.系统调用
应用程序如何安全地请求操作系统内核提供服务？<br/>

宏观过程：<br/>
应用程序在用户态调用系统调用库函数（如 write()）。<br/>
库函数通过陷入指令（如 int 0x80, syscall）触发一个软中断/异常。<br/>
CPU从用户态切换至内核态，并跳转到预设的中断处理程序（即系统调用总入口）。<br/>
内核根据系统调用号查找系统调用表，执行对应的内核服务例程。<br/>
执行完毕，返回结果，并从内核态切换回用户态，应用程序继续执行。<br/>

微观过程：<br/>
设置系统调用号和参数。调用号作为指令的一部分，或装入到特定寄存器里（如：DOS的 int 21H，AH=调用号）。<br/>
参数装入到特定寄存器里，或内存区域。<br/>
执行trap(INT)指令：入口的一般性处理，查入口跳转表，跳转到相应功能的过程。<br/>
保护CPU现场(将PC与PSW入栈)，改变CPU执行状态（处理机状态字PSW切换，地址空间表切换）。<br/>
将参数取到核心空间。<br/>
执行操作系统内部代码；<br/>
执行iret指令：将执行结果装入适当位置，恢复CPU现场（以栈顶内容置PSW和PC）。<br/>

中断是CPU外部的执行流程的事件（异步）<br/>
陷入是CPU内部执行流程的事件（同步）<br/>

### 3.操作系统结构

