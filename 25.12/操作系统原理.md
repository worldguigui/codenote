# 操作系统原理

## 一.操作系统概述
操作系统，Operating System，OS，一句话概括，它会为你完成所有“硬件相关、应用无关”的工作，给你带来方便、效率、安全。<br/>

### 1.地位
对于整个计算机系统来讲，它通常由两部分组成：软件和硬件。<br/>
软件包含两部分：应用软件和系统软件。<br/>
系统软件包含两部分：操作系统和编译软件、汇编软件、数据库管理系统等支撑软件（帮助应用软件被编译或高效运行）。<br/>

他们之间有如下的抽象关系：<br/>

&emsp;应用软件&emsp;|<br/>
——————<br/>
&emsp;&emsp;支撑软件&emsp;&emsp;|<br/>
————————<br/>
&emsp;&emsp;&emsp;操作系统&emsp;&emsp;&emsp;|<br/>
——————————<br/>
&emsp;&emsp;&emsp;&emsp;计算机硬件&emsp;&emsp;&emsp;&emsp;|<br/>
—————————————<br/>

地位：操作系统紧贴计算机硬件之上，所有其他软件之下，是各种软件的基础运行平台。<br/>

### 2.作用
OS的核心目标是高效管理硬件资源，为用户和应用程序提供稳定、安全、易用的运行环境。<br/>

抽象/易用性：将复杂的硬件操作封装成简单、一致的抽象（如“文件”、“进程”），提供统一的设备访问接口，隐藏各设备细节，让程序员和用户无需关心底层细节。<br/>
高性能：让硬件资源（特别是CPU和内存）得到最充分、最合理的利用，减少空闲和浪费。<br/>
公平性：在多个竞争资源的程序（进程）之间进行合理调度（如CPU时间片轮转），保证每个任务都有机会运行，防止某个程序独占资源。<br/>
稳定性：防止一个程序的错误（如非法内存访问）导致整个系统崩溃。<br/>
安全性：对公共系统资源访问提供保护、竞争等功能，对出现的各种错误进行响应、报告。<br/>

### 3.定义
操作系统是一组系统软件的集合，它作为计算机硬件和应用软件/用户之间的中介，管理和控制计算机系统的所有硬件与软件资源，并为用户和应用程序提供一个高效、稳定、安全的运行环境。<br/>

资源，指的是 计算机系统中任何有限的、并且能够被请求、分配、使用和释放的实体。它们有限、可竞争、可管理。<br/>
硬件资源是物理意义上存在的计算机组件，包括硬盘、内存等。<br/>
软件资源是由操作系统内核创建和维护的、用于支持程序运行的逻辑实体，如消息队列、信号量等。它们物理意义上不存在，但也占据一定的硬件资源。<br/>

### 4.发展史
历史不是简单的编年表，而是一条由核心需求（更高效地利用硬件、更方便地与人交互、更稳定地提供服务）驱动，并受限于或得益于当时硬件水平的逻辑链条。<br/>

**1946-1955：电子管时代，无操作系统**<br/>

手工操作阶段，由程序员提前在纸带上打好孔，然后装入纸带输入机。<br/>
此时的计算机内存极小、不稳定。<br/>
内存小，意味着计算机无法容纳一个常驻的“系统”，我们只能让人工来处理输入输出；<br/>
不稳定，意味着机器频繁故障，需要人工干预。<br/>

计算前，手工装入纸带或卡片；人工控制程序执行；计算完成后，手工卸取纸带或卡片。<br/>
用户独占全机资源，在手工操作时，CPU一直在等待用户。再加上此时的计算机高速的cpu运算和低速的人工，导致CPU利用率极低。<br/>

**1955-1965：晶体管时代，单道批处理系统**<br/>

晶体管更小、更快、更可靠。出现了更快的磁芯内存和磁带作为外部存储。<br/>
此时我们计算机的内存更大，足以容纳一个简单的监控程序，操作员事先将若干作业分组，称为一批作业，输入到输入设备上。这个程序可以按顺序读入每个作业并执行。<br/>
这就是单道批处理系统。<br/>

特征：批量性、自动性、顺序性、单道性。<br/>

因为加入了监督程序，作业转换时间减少，系统运行效率提高。<br/>
但是计算机的内存仍有限，在同一时刻，只允许存在一个用户作业并运行。<br/>
虽然此时监控程序允许作业的自动切换，使得资源转换时间减少，但高速CPU还是会在低速I/O操作中等待。<br/>

**1965-1980：集成电路时代，多道批处理系统、分时操作系统、实时操作系统**<br/>

集成电路使计算机性能飙升。<br/>

- 多道批处理系统：<br/>

在内存中同时存放多道已开始运行且尚未结束的程序。它们交替运行，共享系统中的各种资源，从而使处理机得到充分利用。<br/>
当某道程序因为某种原因（例如执行I/O操作时）不能继续运行而放弃CPU时，OS便调度另一程序投入运行。这样可以使CPU和外部设备尽量忙碌。<br/>

特点：多道运行、宏观上并发、微观上串行。<br/>

主存中会有两道及以上的程序在执行中；<br/>
从宏观上看，它们在同时执行；<br/>
从微观上看，它们在交替执行，因为在任一时刻，在一台处理机上只能执行一道程序的一条指令。 <br/>

缺点：交互性差。<br/>

只有在程序结束或中断时，才能与用户交互。<br/>

- 分时操作系统：<br/>

将处理机的运行时间分成很短的时间片，按时间片轮流将处理机分配给各联机终端使用。<br/>
交互式地向系统提出命令请求。<br/>
多个用户分享使用同一台计算机，系统接受每个用户的命令。<br/>
采用时间片轮转方式处理服务请求。如果某用户在分配给它的时间片用完时仍未完成，则暂时中断，等待下一轮运行，并把处理机的控制权让给另一个终端用户使用。<br/>
通过交互方式在终端上向用户显示结果。<br/>
用户根据上步结果发出下道命令 。<br/>

特点：<br/>
多路性：多个用户同时使用一台计算机工作。共享系统资源，提高了资源利用率。<br/>
及时性：用户能在很短时间内得到系统响应。<br/>
独立性：各用户独立操作，互不干扰，好像独占主机。<br/>
交互性：系统能及时对用户的操作进行响应，加快调试过程，缩短了周转时间。<br/>

- 实时操作系统：<br/>

指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。<br/>
计算机开始应用到军事、工业控制领域，对于准时可靠有着极高的要求。<br/>

分类：（根据“错过截止期限”的容忍程度）<br/>
硬实时操作系统：绝对不允许错过截止期限。错过期限意味着系统的完全失败，可能导致灾难性后果。<br/>
软实时操作系统：尽可能不要错过截止期限。偶尔错过是可以接受的，只会导致服务质量下降，不会导致系统崩溃。<br/>

特点：<br/>
响应时间短：任务有明确和固定的时间约束，在一定范围之内必须作出响应。否则任务就会失败，有可能造成灾难性后果。<br/>
系统可靠性高。<br/>

**1980-至今：超大规模集成电路时代，微机操作系统、网络操作系统、分布式操作系统、嵌入式操作系统**<br/>

硬件资源产生飞跃，微处理器出现，个人计算机革命爆发。人们更多考虑如何用好、管好、隔离好。<br/>

衍生的分类：<br/>
微机操作系统：小型化的计算机的操作系统，为单个用户提供丰富、友好的交互体验。<br/>
网络操作系统：拥有网络功能的操作系统，支持进行基于网络协议的可靠的数据传输。<br/>
分布式操作系统：什么是分布式系统？将大量的计算机组织在一起，通过网络进行连接。该操作系统管理 “通过网络连接的多台独立计算机” ，将它们虚拟成一台更强大的单一计算机给用户使用。用户感觉自己在用一台机器，但后台工作可能分布在多台机器上。<br/>
嵌入式操作系统：什么是嵌入式系统？它们是一个大设备、装置或系统中的一部分，完成特定功能的软硬件系统。该操作系统是 “嵌入式环境下的专用计算机系统” 。这个系统通常只为完成特定的控制或处理任务而存在。<br/>

## 二.计算机和操作系统结构
### 1.操作系统和用户的接口
我们（用户和程序员）怎么使用操作系统？<br/>
通过命令接口（用户）或程序接口（程序员）。<br/>

#### 命令接口
联机接口(交互式)：使用系统提供的操作命令，交互地控制程序执行和管理计算机系统。如系统管理、环境设置、权限管理、文件管理等。<br/>
脱机接口：以作业说明书的方式提交给系统(批方式）。执行过程中，用户无法干涉。<br/>

#### 程序接口(系统调用)
这是操作系统为编程人员提供的唯一接口，编程人员利用系统调用，可以在程序中调用操作系统所提供的子功能。<br/>
程序级接口只能在高级语言或汇编语言中作为函数和过程被调用。<br/>

#### 命令解释系统
也叫做shell(外壳)，是OS的重要组件之一，它读入用户的输入或者文件中的命令并运行。通常转换为一个或者多个系统调用。<br/>

有的是在内核中。<br/>
有的则将它作为一个特殊程序，当作业开始或者分时系统中用户登陆时，它运行。如：Unix。<br/>

工作流程<br/>
接收命令：从终端（命令行界面）或脚本文件中读取用户输入的命令。<br/>
解释命令：分析命令字符串，识别命令名、参数、选项和重定向等特殊符号。<br/>
执行命令：<br/>
如果是内部命令（built-in command）：由Shell自身直接执行（如 cd, exit）。<br/>
如果是外部命令：在文件系统中查找对应的可执行程序文件（如 ls, grep），然后通过系统调用（如 fork() + exec()）创建新进程来执行它。<br/>

### 2.系统调用
应用程序如何安全地请求操作系统内核提供服务？<br/>

宏观过程：<br/>
应用程序在用户态调用系统调用库函数（如 write()）。<br/>
库函数通过陷入指令（如 int 0x80, syscall）触发一个软中断/异常。<br/>
CPU从用户态切换至内核态，并跳转到预设的中断处理程序（即系统调用总入口）。<br/>
内核根据系统调用号查找系统调用表，执行对应的内核服务例程。<br/>
执行完毕，返回结果，并从内核态切换回用户态，应用程序继续执行。<br/>

微观过程：<br/>
设置系统调用号和参数。调用号作为指令的一部分，或装入到特定寄存器里（如：DOS的 int 21H，AH=调用号）。<br/>
参数装入到特定寄存器里，或内存区域。<br/>
执行trap(INT)指令：入口的一般性处理，查入口跳转表，跳转到相应功能的过程。<br/>
保护CPU现场(将PC与PSW入栈)，改变CPU执行状态（处理机状态字PSW切换，地址空间表切换）。<br/>
将参数取到核心空间。<br/>
执行操作系统内部代码；<br/>
执行iret指令：将执行结果装入适当位置，恢复CPU现场（以栈顶内容置PSW和PC）。<br/>

中断是CPU外部事件引起的暂停（异步）<br/>
陷入是CPU内部事件引起的暂停（同步）<br/>

### 3.操作系统结构

#### 整体结构/无结构
在最早期开发操作系统时，规模很小，只有几十K字节，较容易实现。设计者主要关注功能的高效实现上，侧重服务功能观点，忽略了软件工程的设计思想。<br/>
那时的操作系统是一组过程的集合，过程之间相互调用，是无结构的，也叫整体结构。<br/>

缺点：因为缺乏清晰的程序结构，所以错误多，调试难，阅读理解难，增加了维护的难度。<br/>

#### 模块化结构
随着新技术的不断发展，OS的功能越来越强，现代OS的代码量越来越多，需要数百人参与，分工合作，共同设计。为克服结构不清晰的缺点，提出模块化结构。<br/>

模块化结构：<br/>
操作系统不再由众多的过程直接组成，而是分成若干个具有一定独立性和大小的模块。如：进程管理模块、内存管理模块、设备管理模块、文件管理模块等。 <br/>
整个系统按功能进行设计和模块划分。<br/>
模块设计、编码和调试独立完成，调用自由。<br/>

缺点：<br/>
系统设计时，模块划分和接口定义不够精确，很难满足实际需求。 <br/>
模块间依赖关系复杂。 随着模块数目增加，设计模块间接口所需要的工作量也在增加。<br/>

#### 分层结构
从资源管理观点出发，将OS划分为若干层次。在某一层次上代码只能调用低层次上的代码，使模块间的调用变为有序。<br/>

通常来讲，硬件相关的、或被调用功能在最低层。如：如缓冲区队列、堆栈操作、时钟管理等 。<br/>
共性的服务放在较低层，活跃功能放在较低层。<br/>
外部特性、资源分配策略放在最外层，如信息管理等，便于修改或适应不同环境。<br/>

缺点：<br/>
层定义困难。<br/>
效率差。每执行一个功能，通常要自上而下地穿越多个层次，降低了运行效率<br/>

#### 微内核结构
从操作系统中去掉尽可能多的东西，而只留一个最小的核心。操作系统=微内核+多个服务器。<br/>

微内核(micro-kernel)<br/>
最基本的核心功能放在内核，它运行于核心态，常驻内存。 如：进程间通信IPC、底层I/O、有限调度和有限进程控制 、最低级的存储管理 、中断处理等。<br/>
绝大部分功能放在微内核外面的一组服务器中实现，如进程服务器、存储服务器、设备服务器等，等待应用程序提出请求，工作在用户态。 <br/>
微内核提供客户程序和运行在用户空间的各种服务之间的通信。<br/>

缺点：消息传递比直接调用效率要低一些 (但可以通过提高硬件性能来补偿 )。<br/>

### 4.现代操作系统的特征
#### 并发（Concurrency）
并发（Concurrency）：宏观上同时运行多个程序，但在微观上这些程序在CPU上交替执行。<br/>
并行（Parallel）：真正的同时执行，需要多核/多CPU硬件支持。<br/>

#### 共享（Sharing）
多个进程共享有限的计算机系统资源。通过共享，资源在一个时间段内被多个进程所用。<br/>

互斥共享：资源分配后到释放前，不能被其他进程所用。如: 打印机、缓冲区。<br/>
同时访问：如内存、磁盘等。 <br/>

#### 虚拟（Virtual）
虚拟就是将一个物理实体映射为若干个对应的逻辑实体。<br/>
它通过“欺骗”每个进程，让其以为自己独占资源。<br/>

#### 异步（Asynchronism）
也称不确定性，指进程的执行顺序和执行时间的不确定性。<br/>

### 5.处理器状态
#### 特权指令和非特权指令
特权指令：只能由操作系统程序使用的指令，如启动I/O设备、控制中断屏蔽位、清内存、加载PSW等。<br/>
非特权指令: 用户程序系统所使用的指令。<br/>

特权指令一般引起处理器状态的切换<br/>

#### 双重操作模式
多道程序系统中，由于采用共享，为了确保安全，根据运行程序对资源和机器指令的使用权限将处理器设置为不同状态/操作模式：<br/>
 一般将处理器工作状态划分为管态/系统模式/内核模式/特权模式和目态/用户模式。<br/>

处理器处于管态时：<br/>
全部指令（包括特权指令）可以执行、可使用所有资源、并具有改变处理器状态的能力。<br/>

处理器处于目态时：<br/>
只有非特权指令能执行。<br/>

#### PSW
PSW(Program Status Word)：寄存CPU运行状态的寄存器。<br/>

CPU如何知道当前运行的是操作系统还是一般应用软件？<br/>
根据PSW中的标识位进行判断。<br/>

#### 管态目态切换
目态→管态<br/>
途径：通过系统调用<br/>
如：INT，Trap，Syscall<br/>

管态→目态<br/>
途径：设置PSW(修改程序状态字)<br/>

## 三.进程
### 1.概述

定义：进程是程序的一次执行过程，它是动态的、独立的、并发的、异步的。<br/>

程序是磁盘上的静态的永久文件，进程是动态的暂时过程。<br/>

描述：进程 = 代码段 + 数据段 + PCB<br/>
PCB（Process Control Block），是操作系统内核中为每个进程维护的一个数据结构。它包含了操作系统管理该进程所需的所有信息。<br/>

### 2.进程控制块PCB
#### 数据结构定义
标识信息： 进程ID（PID）、父进程ID（PPID）。<br/>
状态信息： 进程当前状态（运行、就绪、阻塞等）。<br/>
调度信息： 进程优先级、已等待时间、已执行时间。<br/>
现场信息（重中之重）： 当进程被切换时，其CPU现场（所有寄存器值，尤其是程序计数器PC）被保存在PCB中，以便下次恢复执行。这是实现“并发”的基石。<br/>
资源信息： 内存指针、打开的文件列表、I/O设备分配情况。<br/>

#### PCB实例--上下文
操作系统中把进程物理实体和支持进程运行的环境合称为进程上下文（context）。<br/>
它是恢复一个进程运行所需的全部信息的总和。<br/>
进程的运行被认为是在上下文中执行。<br/>

分类<br/>
用户级上下文：进程的用户地址空间，用户正文段、数据段、用户栈。<br/>
寄存器级上下文：程序寄存器、处理器状态寄存器、栈指针等的值。<br/>
系统级上下文：包括进程的标识信息、现场信息和控制信息，进程环境块，及系统堆栈等组成的进程地址空间。<br/>

#### 进程切换与CPU模式切换
进程切换：让处于运行态的进程中断运行，让出处理器，这时要做一次进程上下文切换、即保存老进程状态而装入被保护了的新进程的状态，以便新进程运行。<br/>

CPU模式切换：当中断发生时，暂时中断正在执行的用户进程，把进程从用户状态切换到内核状态，去执行操作系统程序中的中断处理服务，这就是一次CPU模式切换。<br/>

### 3.进程的状态  
#### 进程的五个状态
就绪态（Ready）：进程已具备运行条件，只等CPU空闲（等待调度器选中）。位于“就绪队列”中。<br/>
执行态（Running）：进程正在CPU上执行指令。<br/>
等待态(阻塞态，waiting，Blocked）：进程因等待某个事件（如I/O完成、信号量）而无法继续执行。即使CPU空闲，它也不能运行。位于“等待队列”中。<br/>
新建状态(new)：刚刚创建的进程，辅存中。<br/>
终止（退出状态，Exit)：终止后进程移入该状态，它不再有执行资格。<br/>

#### 状态转移
运行 → 阻塞：进程主动请求一个暂时无法满足的资源（如read()系统调用等待键盘输入）。<br/>
运行 → 就绪：1）时间片用完（被时钟中断强行切换）；2）被更高优先级进程抢占。<br/>
阻塞 → 就绪：等待的事件发生了（如I/O完成，通过中断通知OS）。<br/>
就绪 → 运行：被调度器选中，称为派发。<br/>

### 4.进程的创建与终止
#### 进程创建
**原因**<br/>
系统初始化：操作系统启动时创建第一个进程（如Unix的init，Linux的systemd）<br/>
用户请求：用户在终端输入命令或双击图标<br/>
进程派生：一个正在运行的进程调用创建进程的系统调用（如fork()）<br/>
批处理作业：批处理系统从作业队列中取出作业创建进程<br/>

**过程**<br/>
分配唯一的进程标识符(PID)<br/>
分配PCB结构并初始化<br/>
为进程分配地址空间<br/>
初始化地址空间（加载程序或复制父进程空间）<br/>
设置进程上下文（寄存器初始值、程序计数器PC等）<br/>
设置进程权限（继承或指定用户/组ID）<br/>
将PCB插入就绪队列<br/>

**系统调用**<br/>
fork（）：创建当前进程的子进程。<br/>

#### 进程终止
**原因**<br/>
正常结束：进程执行完最后一条指令，调用exit()<br/>
错误退出：进程发现自己犯了不可恢复的错误（如除零、越界）<br/>
致命错误：由操作系统检测到的错误（如非法指令、内存访问违规）<br/>
被其他进程杀死：一个进程调用kill()系统调用终止另一个进程<br/>
父进程终止：许多系统规定父进程终止时，所有子进程也终止<br/>

**过程**<br/>
设置进程状态为"终止中"<br/>
释放所有分配的资源（内存、打开文件、I/O设备等）<br/>
通知父进程（发送SIGCHLD信号）<br/>
将退出状态码传递给父进程<br/>
将进程所有子进程的父进程改为init进程<br/>
将PCB从所有队列中移除<br/>
最后释放PCB结构本身<br/>

**系统调用**<br/>
exit（）：终止当前进程。父进程可以通过wait()等待子进程的结束，wait()可以将子进程的标识符返回给父进程。<br/>
exec（）：执行一个可执行程序。程序中 exec（）之后的逻辑不会被执行。<br/>

### 5.进程的组织
如何管理一群进程？接下来先介绍如何组织PCB。<br/>

#### 进程队列模型
按事件类型排成多个队列，可以按多个优先级来划分队列，如：时间片用完->低优，I/O完成->中优，页面调入完成->高优。 <br/>

单阻塞队列：所有阻塞进程都在一个队列中。<br/>
缺点：等待事件发生时，扫描整个队列，时间长。<br/>

多阻塞队列：每个事件对应一个阻塞队列，当事件发生时，相应队列中的所有进程都转换到就绪队列。<br/>

多就绪队列：按照优先级方案分配进程，维护多个就绪队列，每个优先级一个队列，OS可以容易地确定哪个就绪进程具有最高的优先级且等待时间最长。<br/>

#### 进程队列的组织方式
索引方式：按索引表来组织PCB。O（1）查找。<br/>
链接方式：链表。O（1）增删。<br/>
线性方式：数组。实现简单。<br/>

### 6.进程的调度
知道了进程队列如何存储PCB之后，我们要了解如何给进程安排CPU。<br/>

#### 调度层次
高级调度（作业调度）：决定哪个程序可以进入内存成为进程。<br/>
中级调度（内存调度）：决定因内存紧张而被换出（到磁盘）的进程。<br/>
低级调度（CPU调度）：这是核心，决定就绪队列中哪个进程获得CPU。<br/>

#### 调度算法
**先来先服务（First-Come, First-Served，FCFS）：** 当每个进程就绪后，把它加入就绪队列。选择最早进入就绪队列中的进程运行，直到运行结束或因等待I/O等事件而主动阻塞。<br/>
**最短作业优先（Shortest Job First，SJF）：** 选择所需处理时间最短的进程。如果两个进程处理时间相同，则使用FCFS来调度。<br/>
**最短剩余时间优先（Shortest Remaining Time，SRTN）：** SJF的抢占式版本。选择剩余时间最短的进程运行，当一个新的进程到达的时候，如果其所需时间比当前运行进程的剩余时间更少，当前进程就会被挂起，而运行新的进程。<br/>
**优先级调度（Priority Scheduling，PS）：** 选择优先级最高的作业或者进程，将CPU分配给它。具有相同优先级的进程按 FCFS 顺序调度。<br/>
**最高响应比优先（HRRN）：** 每次选取响应比R最高者投入运行。R = (等待时间 + 服务时间) / 服务时间。<br/>
**时间片轮转法（Round Robin，RR）：** 分时系统的核心，公平，响应时间快。<br/>
**多级反馈队列（MLFQ）：** 设立多个优先级不同的就绪队列，每个队列拥有独立的时间片大小（通常高优先级队列时间片短，低优先级队列时间长）和调度策略（高优先级队列常用RR，低优先级队列可用FCFS）。新进程进入最高优先级队列。进程根据其运行时行为（是否在用完时间片前主动放弃CPU）在队列间动态移动。<br/>

### 7.进程间通信IPC
进程间需要能够进行通信来完成并发操作。<br/>

操作系统提供了一种机制，使协作进程通过进程间通信（IPC）工具来进行彼此间的通信。<br/>
包括管道、消息、共享存储区、信号量、信号。<br/>

#### 管道
管道是一条在进程间以字节流方式传送的通信通道。<br/>
它由OS核心的缓冲区（通常几十KB）来实现，是单向的，是一个先进先出（FIFO）的队列，由一个进程写，一个进程读。<br/>

#### 共享存储区
系统在存储区中划出一块共享存储区，各进程间可通过对共享存储区中的数据进行读或写来实现通信。<br/>
需要通信的各个进程把共享存储区附加到自己的地址空间中，然后，就像读写普通存储器一样对共享区中的数据进行读或者写。<br/>
如果用户不需要某个共享存储区，可以把它取消。<br/>

共享存储区很方便，但同时带来了很严重的同步问题，通常要与信号量（或互斥锁）等同步机制配合使用，以保证数据一致性。<br/>

#### 消息队列
消息传递：是相互合作的并发进程交换信息的一种方式，进程间的数据交换以消息为单位。<br/>
消息队列：每个进程有一个与之相关的消息队列。<br/>
消息：一段文本。<br/>
发送者：指定发送的每个消息的类型，类型可以被接收者用作选择原则，接收者可以按先进先出的顺序接收消息，或者按类型接收。<br/>
当进程向一个满队列发送消息时，它将被挂起；<br/>
当进程从一个空队列读取时也会被挂起。<br/>

#### 信号量
semaphore是一个数据结构，定义如下：
```
struct semaphore{
    // s.count>= 0，表示可用的资源数；s.count<0，绝对值为当前等待临界区的进程数。
    int  count;
    // 阻塞在该信号量的各个进程的标识。
    Pointer_PCB queue;
};
// 信号量声明
semaphore s;
```

OS对信号量只能通过初始化和两个标准的原语来访问。<br/>

对信号量的操作只有三种原子操作:<br/>
1.初始化: 通常将信号量的值初始化为非负整数<br/>
2.P操作(wait操作）<br/>
使信号量的值减1(申请一个单位的资源 (s.count--))<br/>
如果使信号量的值变成负数, 则执行P操作的进程被阻塞(当s.count < 0时, 资源已分配完毕, 进程自己阻塞在S的队列上----让权等待)<br/>
3.V操作(signal操作）<br/>
使信号量的值加1(释放一个单位资源 (s.count++))<br/>
如果信号量的值不是正数, 则使一个因执行v操作被阻塞的进程解除阻塞(若s.count <= 0, 则唤醒一个等待进程)<br/>













