# 人工智能导论
我们接下来将会从符号主义AI（Symbolic AI），也可以叫做古典AI（Classical AI）来认识人工智能，这是人工智能在20世纪50年代至80年代占据主导地位的研究范式。<br/>

不同于现代AI，古典AI的核心思想是“智能即计算” + “物理符号系统假说”<br/>
古典AI认为：<br/>

1.智能行为可以通过对符号（Symbols）的操纵来实现。符号可以是任何能代表概念、对象或关系的标识，例如：猫、在...上、桌子。<br/>
2.知识可以显式地用逻辑规则（If-Then规则）和知识库来表示。例如：“如果X是鸟，那么X会飞”（但需处理例外，如鸵鸟）。<br/>
3.推理（Reasoning）是智能的核心。通过逻辑推理算法（如演绎、归纳），系统可以从已知事实推导出新结论，从而解决问题。<br/>

## 一.导论
### 1.1 什么是人工智能

Nilsson认为“AI是关于知识的科学，即怎样表示知识、获取知识和使用知识的科学”（知识）<br/>
Winston则认为“AI是研究如何使计算机去做过去只有人才能做的富有智能的工作”（功能）<br/>
Feigenbaum认为“AI是一个智能计算机的知识处理系统，该系统显示人类行为中与智能有关的某些特征”（系统）<br/>

定义1:  人工智能是一门研究如何使计算机系统显示智能行为的学科，即研究如何让计算机完成那些过去只有人才能做的富有智能的工作。<br/>
定义2:  人工智能是研究如何制造出人造的智能机器或智能系统，来模拟人类智能活动的能力，以延伸人们智能的科学。<br/>
定义3:  AI 是使计算机像人一样思考、行动或能够进行理性地思考、行动的技术。<br/>

简而言之。<br/>

人工智能：即Artificial Intelligence，简称AI，它的基本含义是让计算机模仿人脑去完成一些需要智能的工作。<br/>
计算机：主要功能是计算，也就是数据或信息的处理。<br/>
信息-知识-智能：信息经过抽象、结晶，转化为知识；信息经过提炼、升华，转化为智能；智能经过发挥、使用，促进信息化的发展。<br/>

### 1.2 什么是智能？
对智能的定义是所有问题的起点。我们首先要区分两种定义：<br/>
**像人一样思考与行动 —— “强AI”与图灵测试**<br/>
图灵测试（1950）：由艾伦·图灵提出。核心思想是，如果一个人类评判员通过文本对话，无法区分幕后的对话者是机器还是人，那么这台机器就通过了测试，可以被认为具有智能。<br/>
意义：图灵规避了“智能”的哲学定义，转而提供了一个可操作、可检验的行为主义标准。这为AI研究设立了第一个清晰、务实的目标。<br/>
强AI（通用AI）目标：旨在创造真正具有知觉、意识、能理解世界的机器。通过图灵测试常被视为强AI的一个里程碑。<br/>

**理性地思考与行动 —— “弱AI”与智能体**<br/>
理性智能体：这是现代AI（包括古典AI）更主流的范式。我们不关心它是否像人，只关心它在给定所知道的信息后，是否能做出最优的（或至少是好的）决策来达成目标。<br/>
核心：“理性”意味着最大化预期效用。这依赖于内部的知识表示和逻辑推理能力，而不仅仅是外在模仿。<br/>
弱AI（专用AI）目标：旨在建造能解决特定领域复杂问题的智能系统（如下棋、诊断疾病），它可能表现得非常聪明，但并不声称拥有真正的意识或理解力。<br/>

**何为智能？**<br/>
人类在认识世界和改造世界的活动中，由脑力劳动表现出来的能力，即人们处理事物、解决问题时表现出来的智慧和能力，它是知识和智力的总和。<br/>

智能行为具有如下能力：<br/>
感知能力、表达能力、记忆与思维能力、适应能力、自学习能力.<br/>

### 1.3 AI的发展
**奠基期（1950s）：**<br/>
1950年：图灵发表《计算机器与智能》，提出图灵测试。<br/>
1956年：达特茅斯会议。约翰·麦卡锡、马文·明斯基、克劳德·香农等先驱首次提出“人工智能”这一术语，标志AI作为一门独立学科的诞生。他们当时乐观地认为，几十年内就能制造出具有人类水平智能的机器。<br/>

**黄金期与符号主义的胜利（1960s-1970s）：**<br/>
“物理符号系统假说”（由纽厄尔和西蒙提出）：这是古典AI的基石。假说认为：一个物理符号系统（如计算机）具有必要的充分手段来实现一般智能行动。 简单说，智能可以通过对符号（如逻辑命题）的操作来实现<br/>
成就：诞生了第一个AI程序“逻辑理论家”；开发了早期的问题求解器（如通用问题求解器GPS）；发明了Lisp和Prolog等AI编程语言；专家系统开始萌芽。<br/>

**应用期与现实的挑战（1980s）：**<br/>
专家系统的繁荣：将领域专家（如医生、地质学家）的知识编码为规则，在特定领域（如MYCIN医学诊断、DENDRAL化学分析）取得巨大商业成功。这验证了符号主义的实用性。<br/>
根本困境显现：知识获取成为瓶颈（“知识工程”艰难且昂贵）；系统脆弱，无法处理规则未涵盖的情况；常识知识难以表征（如“水是湿的”、“物体松开后会掉落”）。这暴露了自上而下设计的局限性。<br/>

**反思与低谷（“AI冬天”，1980s末-1990s）：**<br/>
过高的期望未能实现，资助大幅减少。AI研究进入寒冬。<br/>
启示：研究者们认识到，实现人类水平的通用智能，远比想象中复杂。这催生了新的研究思路，为后续连接主义（神经网络）的复兴和概率方法的兴起埋下伏笔。<br/>

我们总会天真的认为，世间所有知识可以用形如∀x→f(x)的形式表示出来，但我们错了，世界上的知识多如牛毛，<br/>
我们认为“鸟通常会飞”。∀x (Bird(x) → CanFly(x))。<br/>
但是，企鹅是鸟但不会飞。所以需要例外：∀x (Penguin(x) → ¬CanFly(x))。<br/>
受伤的鸟不会飞，雏鸟不会飞，被胶水粘住的鸟不会飞，死鸟不会飞，神话中的石像鬼是鸟但不会飞…… “会飞”这个简单属性，就关联着生物、物理、神话、状态等无数其他知识。<br/>
最终为了准确描述“鸟会飞”，你可能需要成千上万条相互关联的规则。而这样的常识概念，人类拥有数以百万计。<br/>

### 1.4 AI的不同实现路径
古典AI并非唯一答案，不同范式可以作简单地了解。<br/>

**符号主义（古典AI的核心）：**<br/>
核心：智能源于对内部显式符号（如逻辑表达式）的操作和推理。认知过程类似于“计算”。<br/>
类比：自上而下。先设计好思维规则（软件），再让机器运行。<br/>
优势：可解释、可预测、善推理。你可以追踪专家系统的推理链，问它“为什么”。<br/>

**连接主义（现代机器学习的主流）：**<br/>
核心：智能源于大量简单处理单元（神经元）之间的连接权重。通过学习和训练调整权重，从数据中涌现出智能。<br/>
类比：自下而上。从数据中学习模式（硬件互联）。<br/>
与古典AI对比：它不处理显式符号和逻辑规则，而是处理数值向量和统计模式。不可解释，但善感知、模式识别。<br/>

**行为主义（具身AI、机器人学的基础）：**<br/>
核心：智能表现为与环境的交互，是简单行为模块（如避障、寻光）在复杂环境中产生的整体表现。“智能存在于世界中，而不在头脑中”。<br/>
类比：由外而内。从与物理世界的互动中产生智能。<br/>
与古典AI对比：反对复杂的内部符号表征，强调实时反应。<br/>


## 二.知识表示与推理
### 2.1 概述
知识表示是古典AI实现智能的核心环节，它将外部世界的信息转化为机器可操作的内部符号结构。<br/>
### 2.2 命题逻辑
语法：用符号表示命题（一个可真可假的陈述句），如 P：今天下雨，Q：我带伞。<br/>

逻辑连接词：¬（非），∧（与），∨（或），→（蕴含），↔（当且仅当）。<br/>

推理方法：<br/>
模型检查：枚举所有可能的世界（真值指派），看结论是否在所有满足前提的世界中都为真。<br/>v
推理规则：更高效的语法推导。如假言推理：(P → Q) ∧ P ⇒ Q。<br/>

### 2.3 一阶谓词逻辑
一阶谓词逻辑是古典AI知识表示的核心工具，它引入了对象、谓词、函数和量词的概念。<br/>

基本元素：<br/>
常量/变量：表示对象，如 Alice， x<br/>
谓词：描述对象的性质或关系，如 Student(Alice)， Loves(x, AI)<br/>
函数：将对象映射到对象，如 MotherOf(Alice)<br/>
量词：<br/>
∀x：对于所有x...<br/>
∃x：存在一个x...<br/>

示例：<br/>
"所有学生都喜欢人工智能"：∀x (Student(x) → Loves(x, AI))<br/>
"每个人都有母亲"：∀x ∃y Mother(y, x)<br/>

### 2.4 推理与归结原理
归结原理是一种强大且完备的自动推理方法，通过以下步骤证明一个语句是否从知识库中逻辑蕴含：<br/>

取反：将待证明的结论取反加入知识库<br/>
标准化：将所有公式转化为子句形式<br/>
合一：找到变量的替换，使两个谓词表达式变得相同<br/>
归结：应用归结规则产生新的子句，直到出现空子句（矛盾）或无法产生新子句<br/>

合一是自动推理的引擎，它找到变量的替换使两个表达式匹配，例如合一 P(x, f(y)) 和 P(a, f(g(z))) 得到替换 {x/a, y/g(z)}。<br/>

## 三.其他知识表示方法--产生式系统
### 3.1 概述
产生式系统是古典AI的一个经典实例。<br/>
自然界中各种知识单元间存在着大量的因果关系<br/><br/>
产生式（规则）：前提和结论之间的关系式<br/>
表示形式：前提->结论<br/>
例：如果获得学士学位->就有资格考取硕士研究生<br/><br/>
事实：无需前提条件，可用于表示已知的事实<br/>
表示形式：->事实<br/>

### 3.2 基本结构
三部分：综合数据库、产生式规则、控制系统。<br/><br/>
1.综合数据库：数据结构，问题工作状态或有关事实（表示问题的信息，短期记忆）<br/>
2.一组产生式规则构成了规则库（知识，长期记忆）<br/>
每一条规则形如:<br/>
if  条件  then  行动 或 if  前提  then  结论<br/>
3.控制系统：解释程序或执行程序，选择规则的原则和规则使用的方式 (推理方向)，并根据综合数据库的信息，控制求解问题的过程（又称认知处理器、控制策略、推理引擎、解释程序等） <br/>

各组成部分的特点：<br/>
1.综合数据库：<br/>
依据推理情况内容动态变化，存放初始状态、已知事实、推理的中间结果及结论等。 <br/>
2.规则库：<br/>
存放一系列规则，有相对固定的格式，规则独立，具有高度模块化。用于描述状态的转换关系、前提与结论间的因果关系等。 <br/>
3.控制系统：<br/>
如何应用规则，与问题无关，可分匹配、选择（冲突解决）和应用（操作）三步。涉及规则推理方向、规则应用的解释、系统运行的结束等 <br/>

三者相互独立。<br/>

相互影响的间接性：“数据 (状态) 驱动”，是通过修改数据库来间接实现。<br/>

关系：综合数据库是基础，产生式规则是进行推理的依据， 控制系统是中枢。 <br/>

### 3.3 基本过程
基本过程就是不断循环“匹配、选择、执行”的PRODUCTION过程。<br/>
1．DATA <- 初始数据库 (初态)<br/>
2．Until DATA 满足结束条件之前(目标态)，do：（匹配）<br/>
3．{<br/>
4．在规则集中，选一条可应用于DATA的规则R（选择）<br/>
5． DATA <- R 应用到  DATA  得到的结果（执行）<br/>
6．}<br/>

### 3.4 问题表示
产生式运用的方法：把待求解问题的描述转化成系统的三个部分。<br/>
基础：问题的表示（综合数据库和规则集）<br/>
类型：状态空间法和问题归约法，马上就会提到。<br/>
状态空间法：给出所求问题的各种状态，通过对可能的状态空间的搜索求得一个解。（PRODUCTION过程）<br/>
问题归约法：在解较复杂的问题时，将问题分解为一些较简单的子问题，通过对各个子问题解答的搜索求得原问题的解答。 （SPLIT过程）<br/>

### 3.5 状态空间法
我们用三元组（S，O，G）来描述， S 状态（某事实的符号或数据）集合、起始状态S0 、中间状态Si 、目标状态G 。 O 是操作算子（规则集）。<br/>
状态空间：所有可能的状态集合S。<br/>
状态转换：靠O中的操作算子(规则)实现。<br/>
问题求解：从S0出发，经过一系列操作变换，达到G，即状态空间搜索问题。状态空间的一个解是一个从初态到目标态的有限的规则序列。<br/>


## 四.搜索策略
我们知道了知识的表示，接下来我们需要了解如何得到解。<br/>

### 4.1 问题形式化
在应用搜索前，必须将现实问题抽象为以下元素：<br/>

状态：对世界在某个时刻的完整描述<br/>
初始状态：起点<br/>
行动/转换函数：给定一个状态，返回所有可能的后继状态及其代价<br/>
目标测试：检查给定状态是否为目标状态<br/>
路径代价函数：每条路径的代价（如步数、时间、能耗）<br/>

示例：八数码问题<br/>
状态：3x3棋盘上的数字布局<br/>
初始状态：任意乱局<br/>
行动：将空白格与相邻数字交换<br/>
目标测试：布局是否为 1 2 3; 4 5 6; 7 8 _<br/>
代价：每移动一步代价为1<br/>

### 4.2 无信息搜索（盲目搜索）
广度优先搜索（BFS）：<br/>
使用队列（FIFO）<br/>

深度优先搜索（DFS）：<br/>
使用栈（LIFO）<br/>

### 4.3 有信息搜索（启发式搜索）
启发式搜索利用启发函数h(n)来引导搜索方向。<br/>
启发函数h(n)：估算从节点n到目标节点的最小代价。h(n)越小，表示n越接近目标。<br/>

例：八数码问题中，h(n)可以是"错误放置的方块数"或更优的"曼哈顿距离"。<br/>

贪婪最佳优先搜索：<br/>
策略：总是扩展当前看来离目标最近的节点，即 h(n) 最小的节点<br/>
缺点：贪心，目光短浅，不保证最优，可能被误导<br/>

A*搜索：<br/>
策略：综合考量"已花费代价"和"预计剩余代价"。定义评估函数 f(n) = g(n) + h(n<br/>

g(n)：从初始节点到n的实际代价<br/>
h(n)：从n到目标的估计代价<br/>

算法：总是扩展 f(n) 最小的节点。使用优先队列<br/>

关键定理：<br/>
可采纳性：如果 h(n) 从不高估真实代价（即 h(n) ≤ h*(n)），则A*保证能找到最优解<br/>
一致性（单调性）：如果对于每个节点n和其后继n'，满足 h(n) ≤ c(n, a, n') + h(n')，则A*在扩展节点时不会重新调整，效率更高。<br/>

### 4.4 对抗搜索（博弈中的搜索）
对抗搜索适用于零和博弈（如象棋、围棋），使用的是与或图结构。<br/>

与或图特性：<br/>
MAX层（或节点）：我方决策点，选择子节点的最大值<br/>
MIN层（与节点）：对手决策点，必须考虑对手所有可能的回应，取子节点的最小值<br/>

最小最大算法：<br/>
核心：假设对手理性且总选择对"你"最不利的走法<br/>
过程：构建博弈树，MAX层选子节点最大值，MIN层选子节点最小值，从叶节点倒推回根节点<br/>

α-β剪枝：<br/>
核心：对最小最大树的优化，提前终止不可能比已知选择更好的分支<br/>
效果：大幅减少需要评估的节点数，使搜索更深<br/>



