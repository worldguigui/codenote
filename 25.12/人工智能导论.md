# 人工智能导论
我们接下来将会从符号主义AI（Symbolic AI），也可以叫做古典AI（Classical AI）来认识人工智能，这是人工智能在20世纪50年代至80年代占据主导地位的研究范式。<br/>

不同于现代AI，古典AI的核心思想是“智能即计算” + “物理符号系统假说”<br/>
古典AI认为：<br/>

1.智能行为可以通过对符号（Symbols）的操纵来实现。符号可以是任何能代表概念、对象或关系的标识，例如：猫、在...上、桌子。<br/>
2.知识可以显式地用逻辑规则（If-Then规则）和知识库来表示。例如：“如果X是鸟，那么X会飞”（但需处理例外，如鸵鸟）。<br/>
3.推理（Reasoning）是智能的核心。通过逻辑推理算法（如演绎、归纳），系统可以从已知事实推导出新结论，从而解决问题。<br/>

## 一.导论
### 1.1 什么是人工智能

Nilsson认为“AI是关于知识的科学，即怎样表示知识、获取知识和使用知识的科学”（知识）<br/>
Winston则认为“AI是研究如何使计算机去做过去只有人才能做的富有智能的工作”（功能）<br/>
Feigenbaum认为“AI是一个智能计算机的知识处理系统，该系统显示人类行为中与智能有关的某些特征”（系统）<br/>

定义1:  人工智能是一门研究如何使计算机系统显示智能行为的学科，即研究如何让计算机完成那些过去只有人才能做的富有智能的工作。<br/>
定义2:  人工智能是研究如何制造出人造的智能机器或智能系统，来模拟人类智能活动的能力，以延伸人们智能的科学。<br/>
定义3:  AI 是使计算机像人一样思考、行动或能够进行理性地思考、行动的技术。<br/>

简而言之。<br/>

人工智能：即Artificial Intelligence，简称AI，它的基本含义是让计算机模仿人脑去完成一些需要智能的工作。<br/>
计算机：主要功能是计算，也就是数据或信息的处理。<br/>
信息-知识-智能：信息经过抽象、结晶，转化为知识；信息经过提炼、升华，转化为智能；智能经过发挥、使用，促进信息化的发展。<br/>

### 1.2 什么是智能？
对智能的定义是所有问题的起点。我们首先要区分两种定义：<br/>
**像人一样思考与行动 —— “强AI”与图灵测试**<br/>
图灵测试（1950）：由艾伦·图灵提出。核心思想是，如果一个人类评判员通过文本对话，无法区分幕后的对话者是机器还是人，那么这台机器就通过了测试，可以被认为具有智能。<br/>
意义：图灵规避了“智能”的哲学定义，转而提供了一个可操作、可检验的行为主义标准。这为AI研究设立了第一个清晰、务实的目标。<br/>
强AI（通用AI）目标：旨在创造真正具有知觉、意识、能理解世界的机器。通过图灵测试常被视为强AI的一个里程碑。<br/>

**理性地思考与行动 —— “弱AI”与智能体**<br/>
理性智能体：这是现代AI（包括古典AI）更主流的范式。我们不关心它是否像人，只关心它在给定所知道的信息后，是否能做出最优的（或至少是好的）决策来达成目标。<br/>
核心：“理性”意味着最大化预期效用。这依赖于内部的知识表示和逻辑推理能力，而不仅仅是外在模仿。<br/>
弱AI（专用AI）目标：旨在建造能解决特定领域复杂问题的智能系统（如下棋、诊断疾病），它可能表现得非常聪明，但并不声称拥有真正的意识或理解力。<br/>

**何为智能？**<br/>
人类在认识世界和改造世界的活动中，由脑力劳动表现出来的能力，即人们处理事物、解决问题时表现出来的智慧和能力，它是知识和智力的总和。<br/>

智能行为具有如下能力：<br/>
感知能力、表达能力、记忆与思维能力、适应能力、自学习能力.<br/>

### 1.3 AI的发展
**奠基期（1950s）：**<br/>
1950年：图灵发表《计算机器与智能》，提出图灵测试。<br/>
1956年：达特茅斯会议。约翰·麦卡锡、马文·明斯基、克劳德·香农等先驱首次提出“人工智能”这一术语，标志AI作为一门独立学科的诞生。他们当时乐观地认为，几十年内就能制造出具有人类水平智能的机器。<br/>

**黄金期与符号主义的胜利（1960s-1970s）：**<br/>
“物理符号系统假说”（由纽厄尔和西蒙提出）：这是古典AI的基石。假说认为：一个物理符号系统（如计算机）具有必要的充分手段来实现一般智能行动。 简单说，智能可以通过对符号（如逻辑命题）的操作来实现<br/>
成就：诞生了第一个AI程序“逻辑理论家”；开发了早期的问题求解器（如通用问题求解器GPS）；发明了Lisp和Prolog等AI编程语言；专家系统开始萌芽。<br/>

**应用期与现实的挑战（1980s）：**<br/>
专家系统的繁荣：将领域专家（如医生、地质学家）的知识编码为规则，在特定领域（如MYCIN医学诊断、DENDRAL化学分析）取得巨大商业成功。这验证了符号主义的实用性。<br/>
根本困境显现：知识获取成为瓶颈（“知识工程”艰难且昂贵）；系统脆弱，无法处理规则未涵盖的情况；常识知识难以表征（如“水是湿的”、“物体松开后会掉落”）。这暴露了自上而下设计的局限性。<br/>

**反思与低谷（“AI冬天”，1980s末-1990s）：**<br/>
过高的期望未能实现，资助大幅减少。AI研究进入寒冬。<br/>
启示：研究者们认识到，实现人类水平的通用智能，远比想象中复杂。这催生了新的研究思路，为后续连接主义（神经网络）的复兴和概率方法的兴起埋下伏笔。<br/>

我们总会天真的认为，世间所有知识可以用形如∀x→f(x)的形式表示出来，但我们错了，

### 1.4 AI的不同实现路径
古典AI并非唯一答案，不同范式可以作简单地了解。<br/>

**符号主义（古典AI的核心）：**<br/>
核心：智能源于对内部显式符号（如逻辑表达式）的操作和推理。认知过程类似于“计算”。<br/>
类比：自上而下。先设计好思维规则（软件），再让机器运行。<br/>
优势：可解释、可预测、善推理。你可以追踪专家系统的推理链，问它“为什么”。<br/>

**连接主义（现代机器学习的主流）：**<br/>
核心：智能源于大量简单处理单元（神经元）之间的连接权重。通过学习和训练调整权重，从数据中涌现出智能。<br/>
类比：自下而上。从数据中学习模式（硬件互联）。<br/>
与古典AI对比：它不处理显式符号和逻辑规则，而是处理数值向量和统计模式。不可解释，但善感知、模式识别。<br/>

**行为主义（具身AI、机器人学的基础）：**<br/>
核心：智能表现为与环境的交互，是简单行为模块（如避障、寻光）在复杂环境中产生的整体表现。“智能存在于世界中，而不在头脑中”。<br/>
类比：由外而内。从与物理世界的互动中产生智能。<br/>
与古典AI对比：反对复杂的内部符号表征，强调实时反应。<br/>

## 二.产生式系统
### 2.1 概述
产生式系统是古典AI的一个经典实例。<br/>
自然界中各种知识单元间存在着大量的因果关系<br/><br/>
产生式（规则）：前提和结论之间的关系式<br/>
表示形式：前提->结论<br/>
例：如果获得学士学位->就有资格考取硕士研究生<br/><br/>
事实：无需前提条件，可用于表示已知的事实<br/>
表示形式：->事实<br/>

### 2.2 基本结构
三部分：综合数据库、产生式规则、控制系统。<br/><br/>
1.综合数据库：数据结构，问题工作状态或有关事实（表示问题的信息，短期记忆）<br/>
2.一组产生式规则构成了规则库（知识，长期记忆）<br/>
每一条规则形如:<br/>
if  条件  then  行动 或 if  前提  then  结论<br/>
3.控制系统：解释程序或执行程序，选择规则的原则和规则使用的方式 (推理方向)，并根据综合数据库的信息，控制求解问题的过程（又称认知处理器、控制策略、推理引擎、解释程序等） <br/>

各组成部分的特点：<br/>
1.综合数据库：<br/>
依据推理情况内容动态变化，存放初始状态、已知事实、推理的中间结果及结论等。 <br/>
2.规则库：<br/>
存放一系列规则，有相对固定的格式，规则独立，具有高度模块化。用于描述状态的转换关系、前提与结论间的因果关系等。 <br/>
3.控制系统：<br/>
如何应用规则，与问题无关，可分匹配、选择（冲突解决）和应用（操作）三步。涉及规则推理方向、规则应用的解释、系统运行的结束等 <br/>

三者相互独立。<br/>

相互影响的间接性：“数据 (状态) 驱动”，是通过修改数据库来间接实现。<br/>

关系：综合数据库是基础，产生式规则是进行推理的依据， 控制系统是中枢。 <br/>

### 2.3 基本过程
基本过程就是不断循环“匹配、选择、执行”的PRODUCTION过程。<br/>
1．DATA <- 初始数据库 (初态)<br/>
2．Until DATA 满足结束条件之前(目标态)，do：（匹配）<br/>
3．{<br/>
4．在规则集中，选一条可应用于DATA的规则R（选择）<br/>
5． DATA <- R 应用到  DATA  得到的结果（执行）<br/>
6．}<br/>

### 2.4 问题表示
产生式运用的方法：把待求解问题的描述转化成系统的三个部分。<br/>
基础：问题的表示（综合数据库和规则集）<br/>
类型：状态空间法和问题归约法，马上就会提到。<br/>
状态空间法：给出所求问题的各种状态，通过对可能的状态空间的搜索求得一个解。（PRODUCTION过程）<br/>
问题归约法：在解较复杂的问题时，将问题分解为一些较简单的子问题，通过对各个子问题解答的搜索求得原问题的解答。 （SPLIT过程）<br/>

### 2.5 状态空间法
我们用三元组（S，O，G）来描述， S 状态（某事实的符号或数据）集合、起始状态S0 、中间状态Si 、目标状态G 。 O 是操作算子（规则集）。<br/>
状态空间：所有可能的状态集合S。<br/>
状态转换：靠O中的操作算子(规则)实现。<br/>
问题求解：从S0出发，经过一系列操作变换，达到G，即状态空间搜索问题。状态空间的一个解是一个从初态到目标态的有限的规则序列。<br/>

### 2.6 问题归约法
三元组（S0，O，P）来描述，S0是初始问题，即要求解的问题；P是本原问题集； O操作算子集，通过一个操作算子把一个问题化成若干个子问题。<br/>
思路：由问题出发，运用操作算子产生一些子问题，对子问题再运用操作算子产生子问题的子问题，这样一直进行到产生的问题均为本原问题，则问题得解。<br/>
特点：最终目的是产生本原问题。<br/>
异同：更一般的问题求解方法。<br/>

## 三.产生式系统的搜索策略
我们知道了什么是产生式系统，接下来我们需要了解如何得到解。<br/>

搜索策略的任务: 确定选择规则的方式<br/>
两种基本方式：<br/>
盲目搜索 (无信息引导)：按固定的步骤。<br/>
启发式搜索(有信息引导)：考虑领域的知识。<br/>

### 3.1 状态空间搜索
#### 3.1.1 概述
状态空间‌提供了问题的完整描述，包括所有可能的状态和它们之间的关系，而‌搜索空间‌则是在解决问题过程中实际访问的状态集合，它是状态空间的一个子集，代表了问题求解过程中实际探索的路径‌。<br/>

状态空间的搜索思想是将问题求解转换为状态空间的图搜索。<br/>
一个状态，对应与图中的一个节点。<br/><br/>

表示方法：<br/>
定义一状态空间S （表示状态的数据结构）<br/>
规定一个或多个属于该空间的初始状态S0<br/>
规定一个或多个属于该空间的目标状态G<br/>
规定一组规则 O（状态转换的操作）<br/>

目的： 将非形式化的问题转换成状态空间形式描述后，便可利用状态空间的搜索方法进行求解<br/>

应用规则和控制策略（搜索技术），找出从初始状态到目标状态的一条（或一组）路径<br/>

#### 3.1.2 具体步骤
从初始状态出发，并将它作为当前状态;<br/>

扫描规则集合，挑选适用于当前状态的一些规则作用在其上而得到新的状态，并建立与父母节点的连接指针;<br/>

检查所生成的新状态是否满足结束条件(状态)，<br/>
如果满足，则得解，并可沿着有关指针从结束状态反向到达开始状态，给出一解答路径；<br/>
否则，将这新状态作为当前状态，返回前一步再进行搜索.<br/>


### 3.2 回溯策略
#### 3.2.1 概述
含义:  按规则的一个固定排序，系统地尝试状态空间中各种不同路径的技术. 是一种盲目搜索.<br/>
#### 3.2.2 具体步骤
过程：从初始状态出发，不停地、试探地寻找路径, 当遇到“死胡同”(无可用规则或规则都用完) 就回溯到路径中最近的父节点上，查看该节点是否还有其他的子节点未被扩展，如有，则沿这些子节点继续搜索；如果找到目标，就成功退出搜索，返回解的路径.<br/>
特征：呈现出递归的性质。求解过程在每个节点上的检查遵循着递归方式. <br/>

### 3.3 盲目的图搜索策略
#### 3.3.1 概述
盲目的图搜索包含宽度优先搜索（也叫做广度优先搜索）和深度优先搜索。<br/>
#### 3.3.2 具体步骤
1.G:=G0 (G0=s)，Open:=(s)；G表示图，s为初始节点，设置Open表，放待扩展的节点，最初只含s.<br/>
2.Closed:=( )；设置Closed表, 放已扩展完的节点，起始为空表.<br/>
3.LOOP:  IF Open:=( )，THEN EXIT (FAIL);<br/>
4.n:= FIRST (Open)，REMOVE (n, Open)，ADD (n, Closed); 称n为当前节点.<br/>
5.IF GOAL (n)，THEN EXIT (SUCCESS)；由n返回到s的路径上的指针,可给出解路径.<br/>
6.EXPAND (n) →(mi), G:=ADD(mi, G)；（为实现无环路,子节点集{mi}中应不包含n的先辈节点.）<br/>
7.标记和修改指针（当出现多路径的情况，根据路径耗散值选择最好的解路, 此时子节点分3种情况考虑 {mi}={mj} ∪{mk}∪{ml} ）<br/>
ADD (mj，Open), 并标记mj连接到n的指针;　若子节点（mj) 为Open和Closed中未出现过的.<br/>
计算是否要修改 mk、ml 到 n 的指针；若子节点已出现过，1）mk 表示已出现在 Open 中的子节点，2）ml 表示已出现在 Closed 中的子节点.<br/>
计算是否要修改 ml 到其后继节点的指针；<br/>
8.对 Open 中的节点按某种原则重新排序；<br/>
9.GO LOOP； <br/>


### 3.4 启发的图搜索策略
核心思想：利用所处理问题的启发信息引导搜索<br/>
目的：减少搜索范围，降低问题复杂度. <br/>

#### 3.4.1 图搜索算法A
基本思路：定义一个评价函数 f，对当前待搜索状态进行评估（既考虑从起始节点到节点 n 的花费，又考虑从节点 n 到达目标节点的费用），然后找出一个最有希望的节点来扩展.<br/>

函数形式为：f (n)= g (n)+ h (n) .  n 为被评价的节点。 用此函数值来排列 OPEN 表中节点顺序的图搜索算法称为 A 算法. <br/>

函数符号说明：<br/>
g*(n)、h*(n)：表示各部分实际最短路径的耗散值.<br/>
f*(n) = g*(n) + h*(n)：表示从S出发，通过节点n到目标节点 g 的最短路径的耗散值.<br/>
f (n)、g (n) 和 h (n) 为相应路径耗散值的估计值，是一种预测。 A 算法就是利用这种预测，来达到有效搜索的目的.<br/>
g（n）可根据搜索历史情况对 g*（n）作出估计，显然有 g（n）>= g*（n）. h（n）则依赖于启发信息，通常称为启发函数，是要对未来扩展的方向作出估计.<br/>

A 算法由一般的图搜索算法改变而成.<br/>

控制策略: <br/>
按照 f（n）值递增的顺序对 OPEN 中的元素进行排序，f（n）值小的节点排在前面，大的放在 OPEN 表的后面.<br/>

效果: <br/>
每次扩展节点时，优先选择当前 f（n）值最小的节点来扩展.<br/>


#### 3.4.2 最佳图搜索算法A*
在算法A中，当 h（n）≤ h*（n）时，称其为 A* 算法.

算法A*是算法A的一种实例，如果问题有解，那么它一定可以找到解。


## 四.与或图搜索

